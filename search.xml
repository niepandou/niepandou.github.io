<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/11/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>如何运用strcpy函数</title>
    <url>/2023/11/15/%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89%E5%A6%82%E4%BD%95%E8%BF%90%E7%94%A8strcpy%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="如何运用strcpy函数"><a href="#如何运用strcpy函数" class="headerlink" title="如何运用strcpy函数"></a>如何运用strcpy函数</h1><h2 id="1-strcpy所需要的库函数"><a href="#1-strcpy所需要的库函数" class="headerlink" title="1.strcpy所需要的库函数"></a>1.strcpy所需要的库函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="2-strcpy函数的基本格式与注意事项"><a href="#2-strcpy函数的基本格式与注意事项" class="headerlink" title="2.strcpy函数的基本格式与注意事项"></a>2.strcpy函数的基本格式与注意事项</h2><ul>
<li><p><a href="https://legacy.cplusplus.com/reference/cstring/strcpy/?kw=strcpy">cplusplus对strcpy的描述</a></p>
</li>
<li><p>本人理解<br> strcpy全称为string copy，即字符串拷贝<br>  strcpy的基本格式为strpy（目的地即被拷贝者，源头即拷贝者）<br>  他所代表的含义为：将strcpy函数中源头（即后者）拷贝给相应的目的地（即前者）</p>
</li>
<li><p>举例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> arr1[] = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">	<span class="type">char</span> arr2[] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">	<span class="built_in">strcpy</span>(arr2,arr1);<span class="comment">//strcpy(目的地被复制者，复制源头复制者) </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,arr2)； </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;`</span><br></pre></td></tr></table></figure></li>
</ul>
<p>其输出结果应当为abcde，其中fg为被打印的原因为：在strcpy函数中，arr1拷贝给arr2时，arr1中末尾存在\0，在拷贝后arr2的字符串为”abcde\0fg“，\0代表了终止符，于是打印arr2仅能打印到e。</p>
]]></content>
  </entry>
  <entry>
    <title>杨辉三角形</title>
    <url>/2023/11/15/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%BB%8F%E5%85%B8%E6%95%B0%E5%AD%A6%E9%A2%98%E3%80%91%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="杨辉三角一图览"><a href="#杨辉三角一图览" class="headerlink" title="杨辉三角一图览"></a>杨辉三角一图览</h1><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line">			  			<span class="attribute">1</span></span><br><span class="line">					<span class="attribute">1</span>		<span class="number">1</span></span><br><span class="line">				<span class="attribute">1</span>		<span class="number">2</span>      <span class="number">1</span></span><br><span class="line">			<span class="attribute">1</span>       <span class="number">3</span>	    <span class="number">3</span>      <span class="number">1</span></span><br><span class="line">		<span class="attribute">1</span>		<span class="number">4</span>		<span class="number">6</span>		<span class="number">4</span> 		<span class="number">1</span></span><br><span class="line">	<span class="attribute">1</span>		<span class="number">5</span>		<span class="number">10</span>		<span class="number">10</span>		<span class="number">5</span>		<span class="number">1</span></span><br><span class="line"><span class="attribute">1</span>		<span class="number">6</span>		<span class="number">15</span>		<span class="number">20</span>		<span class="number">15</span>		<span class="number">6</span>		<span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由图可知杨辉三角具有对称性，很多时候可以折半计算，节省时间<br>同时我们可以以排列组合的方式将杨辉三角展现出来</p>
</blockquote>
<p>借个图先<br><img src="https://img-blog.csdnimg.cn/d2a520baba134d9a9f429c858315b96d.png" alt="在这里插入图片描述"></p>
<blockquote>
<h1 id="求杨辉三角任意一行"><a href="#求杨辉三角任意一行" class="headerlink" title="求杨辉三角任意一行"></a>求杨辉三角任意一行</h1><p>我们在编程界中经常把排列组合中的公式用A（a,b），C(a,b)表示<br>比如C（5,2） &#x3D; 10<br>那么对n-1行的公式可以写成<br>C（n，r） &#x3D; （n-r + 1）&#x2F; r * C(n,r-1);<br> 杨辉三角的每一行初始值为C(n,0) &#x3D; 1</p>
</blockquote>
<p> 又根据杨辉三角的对称性，我们可以折半计算，在计算中心轴左边的值的同时也能将右边的值算出来</p>
<p>该公式的应用<br><a href="https://www.luogu.com.cn/problem/P1118">lP1118 [USACO06FEB]Backward Digit Sums G&#x2F;S</a></p>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,sum;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> delta[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getdelta</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	delta[<span class="number">0</span>] = delta[n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(n &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i*<span class="number">2</span> &lt;= n;++i)</span><br><span class="line">			delta[i] = delta[n-i<span class="number">-1</span>] = (n-i) * delta[i<span class="number">-1</span>]/i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> num,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(v &gt; sum) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(u == n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(v == sum)</span><br><span class="line">		&#123;</span><br><span class="line">			a[u] = num;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	st[num] = <span class="literal">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i] &amp;&amp; <span class="built_in">dfs</span>(u + <span class="number">1</span>,i,v + delta[u] * i))</span><br><span class="line">		&#123;</span><br><span class="line">			a[u] = num;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	st[num] = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;sum;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">getdelta</span>();<span class="comment">//得到第n层杨辉三角 </span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)) <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i) cout&lt;&lt;a[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<h1 id="求杨辉三角某一值起始位置"><a href="#求杨辉三角某一值起始位置" class="headerlink" title="求杨辉三角某一值起始位置"></a>求杨辉三角某一值起始位置</h1><p>经过多数人的研究，已经找到了一种非常精妙的方法来快速确定任意值的起始位置，所耗时间只需4ms</p>
</blockquote>
<p>首先再看一次图</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line">			  			<span class="attribute">1</span></span><br><span class="line">					<span class="attribute">1</span>		<span class="number">1</span></span><br><span class="line">				<span class="attribute">1</span>		<span class="number">2</span>      <span class="number">1</span></span><br><span class="line">			<span class="attribute">1</span>       <span class="number">3</span>	    <span class="number">3</span>      <span class="number">1</span></span><br><span class="line">		<span class="attribute">1</span>		<span class="number">4</span>		<span class="number">6</span>		<span class="number">4</span> 		<span class="number">1</span></span><br><span class="line">	<span class="attribute">1</span>		<span class="number">5</span>		<span class="number">10</span>		<span class="number">10</span>		<span class="number">5</span>		<span class="number">1</span></span><br><span class="line"><span class="attribute">1</span>		<span class="number">6</span>		<span class="number">15</span>		<span class="number">20</span>		<span class="number">15</span>		<span class="number">6</span>		<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>我们可以将杨辉三角的右半边删掉，因为杨辉三角的对称性，显而易见我们能推导出任意值的起始位置一定在左半边</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line">			  			<span class="attribute">1</span></span><br><span class="line">					<span class="attribute">1</span>		</span><br><span class="line">				<span class="attribute">1</span>		<span class="number">2</span>      </span><br><span class="line">			<span class="attribute">1</span>       <span class="number">3</span>	    </span><br><span class="line">		<span class="attribute">1</span>		<span class="number">4</span>		<span class="number">6</span>		</span><br><span class="line">	<span class="attribute">1</span>		<span class="number">5</span>		<span class="number">10</span>	</span><br><span class="line"><span class="attribute">1</span>		<span class="number">6</span>		<span class="number">15</span>		<span class="number">20</span>	</span><br></pre></td></tr></table></figure>
<p>得到该图后我们发现，我们可以通过斜行位置与行位置来确定某一值<br>假设起始行数与斜行都为0<br>比如我们求C（6,3），组合数C（6,3） &#x3D; 20<br>该过程代码</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">//C(a,b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = a, j = <span class="number">1</span>;j &lt;= b;--i, ++j)</span><br><span class="line">	&#123;</span><br><span class="line">			res = res * i / j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>同时我们可以确定，这一斜行找到的值的位置，总会比他上面一个斜行找到同一值的位置要小<br>因此我们可以倒着枚举每一斜行来寻找某一值，找到的位置一定是起始位置</p>
<p>而且每一斜行k的起始行数n，总有一种规律 2*k &#x3D; n</p>
<p>现在我们总结一下前面找到的规律<br>1.通过斜行与行的位置可以推断某一值<br>2.倒着枚举每一斜行可以找到该值的第一次出现位置<br>3.斜行k * 2 &#x3D; 斜行起始行数n<br>4.由123点我们可以通过二分查找行来寻找该值，起始行为2*k，终点行为n（选择n是因为n足够大）<br>补充一点，如果已知某一行数n，可以推断该行之前总共有C（n，2）个数，在把斜行看做列，即可得到某一值的位置公式</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pos</span> = (n + <span class="number">1</span>）*n / <span class="number">2</span> + k +<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>例题<br><a href="https://www.luogu.com.cn/problem/P8749">P8749 [蓝桥杯 2021 省 B] 杨辉三角形</a><br>实现代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">//C(a,b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = a, j = <span class="number">1</span>;j &lt;= b;--i, ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		res = res * i / j;</span><br><span class="line">		<span class="keyword">if</span> (res &gt; n) <span class="keyword">return</span> res;<span class="comment">//防止超过n直接爆long long，提前退出</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>)<span class="comment">//因为C（2,1）不存在，需要特判</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">16</span>;i &gt;= <span class="number">1</span>;--i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">long</span> <span class="type">long</span> l = <span class="number">2</span> * i, r = <span class="built_in">max</span>(l, n);<span class="comment">//有可能l比n大</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (l &lt; r)<span class="comment">//二分查找左端点</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">long</span> <span class="type">long</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">C</span>(mid, i) &lt; n) l = mid + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> r = mid;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">C</span>(l, i) == n)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; (l + <span class="number">1</span>) * l / <span class="number">2</span> + i + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
